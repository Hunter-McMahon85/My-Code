Pt 1:

32B direct-mapped w/ 4B blocks.

1. Why 8 cache sets? Hint: direct-mapped is like "one-way" associativity.
because the # of sets = (cache size)/(block size *associativity level) = 32/(4*1) = 8

2. How many offset bits?
log2(4) = 2

3. How many set bits?
log2(8) = 3

4. How many tag bits?
dependent on architecture, in this case:
32b arch thus: 32-3-2 = 27

therefore:
  T  S  O
<27><3><2>

Pt 2: 

Document the cache operations and contents for the following memory reads:

Template:
valid | tag | set | contents
------+-----+-----+---------
      |     |     |

1. 0x00 (0000 0000)
offset: 00
set:    000 = 0
tag:    000 = 0

valid | tag | set | contents
------+-----+-----+---------
  1   | 0   |  0  | M[0:3]

2. 0x04 (0000 0100)
offset: 00
set:    001 = 1
tag:    000 = 0

valid | tag | set | contents
------+-----+-----+---------
  1   | 0   |  0  | M[0:3]
  1   | 0   |  1  | M[4:7]

3. 0x08 (0000 1000)
offset: 00
set:    010 = 2
tag:    000 = 0

valid | tag | set | contents
------+-----+-----+---------
  1   | 0   |  0  | M[0:3]
  1   | 0   |  1  | M[4:7]
  1   | 0   |  2  | M[8:11]

4. 0x0C (0000 1100)
offset: 00
set:    011 = 3
tag:    000 = 0

valid | tag | set | contents
------+-----+-----+---------
  1   | 0   |  0  | M[0:3]
  1   | 0   |  1  | M[4:7]
  1   | 0   |  2  | M[8:11]
  1   | 0   |  3  | M[12:15]

5. 0x10 (0001 0000)
offset: 00
set:    100 = 4
tag:    000 = 0

valid | tag | set | contents
------+-----+-----+---------
  1   | 0   |  0  | M[0:3]
  1   | 0   |  1  | M[4:7]
  1   | 0   |  2  | M[8:11]
  1   | 0   |  3  | M[12:15]
  1   | 0   |  4  | M[16:19]

6. 0x14 (0001 0100)
offset: 00
set:    101 = 5
tag:    000 = 0

valid | tag | set | contents
------+-----+-----+---------
  1   | 0   |  0  | M[0:3]
  1   | 0   |  1  | M[4:7]
  1   | 0   |  2  | M[8:11]
  1   | 0   |  3  | M[12:15]
  1   | 0   |  4  | M[16:19]
  1   | 0   |  5  | M[20:23]

7. 0x18 (0001 1000)
offset: 00
set:    110 = 6
tag:    000 = 0

valid | tag | set | contents
------+-----+-----+---------
  1   | 0   |  0  | M[0:3]
  1   | 0   |  1  | M[4:7]
  1   | 0   |  2  | M[8:11]
  1   | 0   |  3  | M[12:15]
  1   | 0   |  4  | M[16:19]
  1   | 0   |  5  | M[20:23]
  1   | 0   |  6  | M[24:27]

8. 0x1C (0001 1100)
offset: 00
set:    111 = 7
tag:    000 = 0

valid | tag | set | contents
------+-----+-----+---------
  1   | 0   |  0  | M[0:3]
  1   | 0   |  1  | M[4:7]
  1   | 0   |  2  | M[8:11]
  1   | 0   |  3  | M[12:15]
  1   | 0   |  4  | M[16:19]
  1   | 0   |  5  | M[20:23]
  1   | 0   |  6  | M[24:27]
  1   | 0   |  7  | M[28:31]

9. 0x20 (0010 0000)
offset: 00
set:    000 = 0
tag:    001 = 1

valid | tag | set | contents
------+-----+-----+---------
  1   | 1   |  0  | M[32:35]
  1   | 0   |  1  | M[4:7]
  1   | 0   |  2  | M[8:11]
  1   | 0   |  3  | M[12:15]
  1   | 0   |  4  | M[16:19]
  1   | 0   |  5  | M[20:23]
  1   | 0   |  6  | M[24:27]
  1   | 0   |  7  | M[28:31]

----------------------------------------------

full address pnts 2 single byte
however if the offset bit is droped from the address it behaves like a "block pointer"

Time permitting:
For practice on 2-way associativity, redo the process with a 2-way associative cache instead.

1. how many cach sets?
32/(4*2) = 4

2. How many offset bits?
log2(4) = 2

3. How many set bits?
log2(4) = 2

4. How many tag bits?
dependent on architecture, in this case:
32b arch thus: 32-2-2 = 28

  T  S  O
<28><2><2>

1. 0x00 (0000 00 00)
offset: 00
set:    00 = 0
tag:    00 = 0

valid | tag | set | contents
------+-----+-----+---------
  1   | 0   |  0  | M[0:2]

2. 0x04 (0000 01 00)
offset: 00
set:    01 = 1
tag:    00 = 0

valid | tag | set | contents
------+-----+-----+---------
  1   | 0   |  0  | M[0:3]
  1   | 0   |  1  | M[4:7]

3. 0x08 (0000 10 00)
offset: 00
set:    10 = 2
tag:    00 = 0

valid | tag | set | contents
------+-----+-----+---------
  1   | 0   |  0  | M[0:3]
  1   | 0   |  1  | M[4:7]
  1   | 0   |  2  | M[8:11]

4. 0x0C (0000 11 00)
offset: 00
set:    11 = 3
tag:    00 = 0

valid | tag | set | contents
------+-----+-----+---------
  1   | 0   |  0  | M[0:3]
  1   | 0   |  1  | M[4:7]
  1   | 0   |  2  | M[8:11]
  1   | 0   |  3  | M[12:15]

5. 0x10 (0001 00 00)
offset: 00
set:    00 = 0
tag:    01 = 1

valid | tag | set | contents
------+-----+-----+---------
  1   | 0   |  0  | M[0:3]
  1   | 0   |  1  | M[4:7]
  1   | 0   |  2  | M[8:11]
  1   | 0   |  3  | M[12:15]
  1   | 1   |  0  | M[16:19]

6. 0x14 (0001 01 00)
offset: 00
set:    01 = 1
tag:    01 = 1

valid | tag | set | contents
------+-----+-----+---------
  1   | 0   |  0  | M[0:3]
  1   | 0   |  1  | M[4:7]
  1   | 0   |  2  | M[8:11]
  1   | 0   |  3  | M[12:15]
  1   | 1   |  0  | M[16:19]
  1   | 1   |  1  | M[20:23]


7. 0x18 (0001 10 00)
offset: 00
set:    10 = 2
tag:    01 = 1

valid | tag | set | contents
------+-----+-----+---------
  1   | 0   |  0  | M[0:3]
  1   | 0   |  1  | M[4:7]
  1   | 0   |  2  | M[8:11]
  1   | 0   |  3  | M[12:15]
  1   | 1   |  0  | M[16:19]
  1   | 1   |  1  | M[20:23]
  1   | 1   |  2  | M[24:27]

8. 0x1C (0001 11 00)
offset: 00
set:    11 = 3
tag:    01 = 1

valid | tag | set | contents
------+-----+-----+---------
  1   | 0   |  0  | M[0:3]
  1   | 0   |  1  | M[4:7]
  1   | 0   |  2  | M[8:11]
  1   | 0   |  3  | M[12:15]
  1   | 1   |  0  | M[16:19]
  1   | 1   |  1  | M[20:23]
  1   | 1   |  2  | M[24:27]
  1   | 1   |  3  | M[28:31]

9. 0x20 (0010 00 00)
offset: 00
set:    00 = 0
tag:    10 = 2

valid | tag | set | contents
------+-----+-----+---------
  1   | 2   |  0  | M[32:35]
  1   | 0   |  1  | M[4:7]
  1   | 0   |  2  | M[8:11]
  1   | 0   |  3  | M[12:15]
  1   | 1   |  0  | M[16:19]
  1   | 1   |  1  | M[20:23]
  1   | 1   |  2  | M[24:27]
  1   | 1   |  3  | M[28:31]

- the block is full and one set 0 val must be kicked from the party
but which is the best to boot from the squad?
-ideally one we dont need 
hypothetical best:
replace block used *furthest* in the future (impossible)

practical best:
replace the least recently used block (LCU)
- thus  1   | 0   |  0  | M[0:3] is kicked







